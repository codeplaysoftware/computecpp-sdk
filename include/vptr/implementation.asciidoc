== Software Managed Virtual Pointer Implementation

This document contains implementation details of the software-managed
virtual pointer which facilitates a pointer interface for SYCL buffers.

Information on the usage of the virtual pointer can be found in the
link:README.adoc[README file].

=== Data structures

The virtual pointer implementation relies on a `PointerMapper` class
to map the virtual pointer to a SYCL buffer. `PointerMapper` uses the
following structures for this:

* a map which contains the virtual pointers and SYCL buffers
* a set of virtual pointers which have been freed and can be
  reused; sorted by size of free block, in ascending order

The implementations of `SYCLmalloc()` and `SYCLfree()` add and remove
virtual pointers from the map.

=== Pointer reuse

`PointerMapper` tries to reuse virtual pointers, which have been allocated
and freed, in order to minimise the risk of running out of possible virtual
addresses.
The implementation also ensures that minimal fragmentation occurs in the
virtual address space which avoids possible memory leaks (they could occur
when the freed blocks are too small to allocate new pointers, but are still
kept in the list of free pointers).

* *Pointer reuse* is implemented in `SYCLmalloc()`.
When a new virtual pointer is allocated, the implementation looks for a
sufficiently large free pointer. If it finds one, it reuses it. If the
available pointer is larger than the size requested, the implementation
creates a new free pointer of the remaining size and adds it to the set
of freed pointers, so it can be reused in the future.

* *Minimised fragmentation* is implemented in `SYCLfree()`.
When a pointer is being freed, the implementation flags it as free and
adds it to the set of freed pointers. While doing that, it tries to fuse
the freed space with the blocks around it (before and after), provided
that they are free, using the methods below:

** `fuse_forward()`:
Check that the pointer *after* the freed one is free. If it is, add the
size of the forward pointer to the freed one and remove the forward pointer.

** `fuse_backward()`:
Check that the pointer *before* the freed one is free. If it is, add the
size of the freed pointer to the previous one and remove the freed pointer.

If in the end the final free pointer is at the end of the allocated space,
it is removed.
